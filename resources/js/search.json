[[{"l":"Index"}],[{"l":"Welcome","p":["This site is not ready for public consumption. Rough outlines are being created, many times with the help of AI. I'm building this in public and will continuously refine and fill in the gaps.","Feel free to look around, but expect most topics to just be rough drafts or placeholders for later completion"]}],[{"l":"Workstation Setup"},{"l":"Operating System Setup"},{"l":"Desktop","p":["You are going to be looking at your desktop a lot, so pick a background that brings you happiness. Every time you look at it you should feel joy and excitement. I use the following background that I found from https://www.youtube.com/@typecraft_dev"]},{"l":"Git"},{"l":"Installation"},{"l":"Configuration"},{"l":"Aliases"},{"l":"Terminal"},{"l":"Install a Nerd Font"},{"l":"Install WezTerm Terminal"},{"l":"Configure WezTerm Terminal"},{"l":"Install Starship"}],[{"l":"Blogs"},{"l":"Starter Templates","p":["Bullet Train - https://bullettrain.co"]},{"l":"Front End Frameworks","p":["Phlex - https://beautifulruby.com/phlex"]},{"l":"Front End Components","p":["Rails Blocks - https://railsblocks.com","Rails Icons - https://railsdesigner.com/rails-icons/"]},{"l":"Static Site Generators","p":["Site Press - https://sitepress.cc/"]},{"l":"Observability Services","p":["Honeybadger - https://honeybadger.io","Rails Pulse - https://railspulse.com"]},{"l":"Training","p":["Go Rails - https://gorails.com"]}],[{"l":"Software Development Lifecycle (SDLC) Steps","p":["The Software Development Lifecycle (SDLC) is a structured process for planning, creating, testing, deploying, and maintaining software. Below is a comprehensive list of SDLC phases, each with a brief description of its purpose and activities."]},{"l":"1. Requirement Analysis","p":["Description: Gather and analyze project requirements to define the scope and objectives.","Collaborate with stakeholders (clients, end-users, management) to understand needs.","Document functional and non-functional requirements (e.g., features, performance, security).","Create requirement specifications, user stories, or use cases.","Validate requirements to ensure clarity, feasibility, and alignment with business goals."]},{"l":"2. Feasibility Study","p":["Description: Assess the project's viability from technical, financial, and operational perspectives.","Evaluate technical feasibility (e.g., available technology, expertise).","Analyze cost-benefit and resource requirements.","Identify risks and constraints (e.g., time, budget, technology limitations).","Produce a feasibility report to guide decision-making."]},{"l":"3. System Design","p":["Description: Create a blueprint for the software system based on requirements.","Define system architecture (e.g., monolithic, microservices, cloud-based).","Design components, modules, databases, and interfaces.","Specify tools, frameworks, and technologies to be used.","Create detailed design documents, including flowcharts, ER diagrams, and wireframes."]},{"l":"4. Development (Coding)","p":["Description: Write code to implement the system design.","Assign tasks to developers based on design specifications.","Use programming languages, frameworks, and tools to build software components.","Follow coding standards and best practices (e.g., modularity, documentation).","Conduct regular code reviews to ensure quality and consistency."]},{"l":"5. Testing","p":["Description: Verify that the software meets requirements and is free of defects.","Perform unit testing to validate individual components.","Conduct integration testing to ensure modules work together.","Execute system testing to verify the entire system’s functionality.","Perform user acceptance testing (UAT) to confirm the software meets user needs.","Identify and fix bugs, ensuring performance, security, and usability."]},{"l":"6. Deployment","p":["Description: Release the software to the production environment for end-user access.","Plan deployment strategy (e.g., phased rollout, big bang).","Set up production environments (servers, databases, configurations).","Deploy the software using automated tools or manual processes.","Monitor initial performance and address any immediate issues."]},{"l":"7. Maintenance","p":["Description: Provide ongoing support to ensure the software remains functional and relevant.","Monitor system performance and address issues (e.g., bugs, crashes).","Release updates or patches to fix defects or improve functionality.","Incorporate user feedback to enhance features or usability.","Plan for scalability, security updates, and compatibility with new technologies."]},{"l":"8. Retirement (Optional)","p":["Description: Decommission the software when it becomes obsolete or is replaced.","Plan for data migration to new systems if needed.","Archive code, documentation, and data for compliance or future reference.","Notify users and stakeholders of the software’s end-of-life.","Safely shut down the system and dispose of resources."]}],[{"l":"Overview","p":["The \"Gang of Four\" design patterns, from the book Design Patterns: Elements of Reusable Object-Oriented Software by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides, are 23 classic software design patterns. They are categorized into three groups: Creational, Structural, and Behavioral. Below is a bullet list with each pattern's category, name, and a brief description of its purpose."]},{"l":"Creational Patterns","p":["Abstract Factory: Provides an interface for creating families of related or dependent objects without specifying their concrete classes.","Builder: Separates the construction of a complex object from its representation, allowing the same construction process to create different representations.","Factory Method: Defines an interface for creating an object, but lets subclasses decide which class to instantiate.","Prototype: Creates new objects by copying an existing object, known as the prototype, to avoid the overhead of initializing from scratch.","Singleton: Ensures a class has only one instance and provides a global point of access to it."]},{"l":"Structural Patterns","p":["Adapter: Converts the interface of a class into another interface that a client expects, enabling incompatible classes to work together.","Bridge: Decouples an abstraction from its implementation so that the two can vary independently.","Composite: Composes objects into tree structures to represent part-whole hierarchies, allowing clients to treat individual objects and compositions uniformly.","Decorator: Dynamically adds responsibilities to objects in a flexible and reusable way without modifying their code.","Facade: Provides a simplified interface to a complex subsystem, making it easier to use.","Flyweight: Shares fine-grained objects to reduce memory usage and improve performance when dealing with large numbers of similar objects.","Proxy: Controls access to an object by acting as a surrogate or placeholder, often to add functionality like lazy loading or access control."]},{"l":"Behavioral Patterns","p":["Chain of Responsibility: Passes a request along a chain of handlers, allowing each handler to process it or pass it to the next handler.","Command: Encapsulates a request as an object, allowing parameterization of clients with queues, logs, or undoable operations.","Interpreter: Defines a representation for a language's grammar and an interpreter to process expressions in that language.","Iterator: Provides a way to access elements of a collection sequentially without exposing its underlying representation.","Mediator: Defines an object that encapsulates how a set of objects interact, promoting loose coupling by preventing direct references.","Memento: Captures and externalizes an object's internal state so that it can be restored later without violating encapsulation.","Observer: Defines a one-to-many dependency where objects are notified and updated automatically when one object changes state.","State: Allows an object to change its behavior when its internal state changes, appearing as if it changes its class.","Strategy: Defines a family of algorithms, encapsulates each one, and makes them interchangeable, letting the client choose the algorithm at runtime.","Template Method: Defines the skeleton of an algorithm in a method, deferring some steps to subclasses to customize behavior.","Visitor: Separates an algorithm from an object structure by moving the operations to a visitor object, allowing new operations without modifying the structure."]}],[{"l":"Abstract factory pattern"}],[{"l":"Builder pattern"}],[{"l":"Factory method pattern"}],[{"l":"Prototype pattern"}],[{"l":"Singleton pattern"}],[{"l":"Patterns from Martin Fowler's Patterns of Enterprise Application Architecture","p":["Active Record: Encapsulates database access by integrating data and behavior into a single object, where each object corresponds to a database row, simplifying CRUD operations.","Association Table Mapping: Maps an association between two objects to a database table, enabling flexible relationships like many-to-many links in relational databases.","Below is a bullet list of patterns from Martin Fowler's book Patterns of Enterprise Application Architecture(2002). Each pattern includes its name and a brief description of its purpose, based on the book's catalog of solutions for common enterprise application challenges.","Class Table Inheritance: Represents a class hierarchy in a database by creating a table for each class, with shared data in a parent table, supporting inheritance in object-oriented designs.","Coarse-Grained Lock: Locks a group of related objects as a single unit to prevent concurrent modifications, simplifying concurrency control in complex data structures.","Concrete Table Inheritance: Maps each class in a hierarchy to its own database table containing all fields, simplifying queries but potentially duplicating data.","Data Mapper: Separates domain objects from database access logic by using a mapper class to handle data transfer, decoupling the object model from the database schema.","Data Transfer Object: Packages data into a single object to reduce the number of method calls across system boundaries, improving performance in distributed systems.","Dependent Mapping: Delegates the mapping of an object’s fields to another object (e.g., a parent object), reducing redundancy in mapping logic for related objects.","Domain Model: Organizes business logic into a rich object model with behavior and data, enabling complex domain logic while keeping it independent of persistence.","Embedded Value: Stores a small, dependent object’s data directly within its parent’s table, simplifying storage for simple value objects without needing separate tables.","Foreign Key Mapping: Uses foreign keys in a database to represent relationships between objects, enabling navigation and maintaining referential integrity.","Front Controller: Centralizes request handling through a single controller to manage web requests, ensuring consistent processing and reducing duplication in web applications.","Gateway: Encapsulates access to an external system or resource (e.g., a database or service) through a simple interface, simplifying interaction and isolating external dependencies.","Identity Field: Adds a unique field (e.g., a primary key) to an object to map it to a database record, ensuring consistent identification across layers.","Identity Map: Maintains a cache of objects by their identity to ensure each database record is loaded only once, preventing duplicate objects and improving performance.","Implicit Lock: Manages concurrency by automatically applying locks during transactions, simplifying locking logic for developers but potentially reducing flexibility.","Inheritance Mappers: Uses separate mapper classes for each class in an inheritance hierarchy to handle persistence, supporting complex object hierarchies.","Layer Supertype: Provides a common superclass for all objects in a layer to share common behavior, reducing duplication across similar objects in a layer.","Lazy Load: Delays loading of an object’s data until it’s needed, improving performance by reducing unnecessary database queries.","Metadata Mapping: Stores mapping information (e.g., between objects and database tables) in metadata, enabling flexible and configurable persistence logic.","Model View Controller: Separates application concerns into models (data and logic), views (UI), and controllers (input handling), improving modularity and testability.","Money: Represents monetary values with a specific currency and handles arithmetic and rounding, ensuring accurate financial calculations.","Optimistic Offline Lock: Allows concurrent access to data by checking for conflicts only at commit time, improving performance in low-conflict scenarios.","Page Controller: Handles web requests for a specific page or action with a dedicated controller, simplifying handling for straightforward web applications.","Plugin: Enables dynamic loading of components or modules at runtime, improving extensibility and configurability of applications.","Query Object: Encapsulates a database query as an object, allowing complex queries to be built and reused while keeping persistence logic separate.","Record Set: Represents tabular data (e.g., query results) as an in-memory structure, providing a flexible way to manipulate data in applications.","Registry: Provides a central point to access commonly used objects or services, simplifying access and reducing coupling across the system.","Remote Facade: Exposes a coarse-grained interface to hide the complexity of a fine-grained object model, improving performance in distributed systems.","Repository: Centralizes data access logic for a domain type, providing a collection-like interface to query and manage domain objects.","Row Data Gateway: Represents a single database row as an object with fields and access methods, simplifying data access for simple applications.","Separated Interface: Defines an interface in a separate package from its implementation to reduce coupling and allow multiple implementations.","Serialized LOB: Stores a large object (LOB), like a complex object graph, as a serialized blob in a database, simplifying storage of complex data.","Service Layer: Centralizes business logic into a distinct layer that coordinates operations across domain objects, improving maintainability and modularity.","Service Stub: Replaces an external service with a simplified version for testing or development, isolating the system from external dependencies.","Session State: Manages user session data (e.g., in web applications) to maintain state between requests, supporting user-specific interactions.","Single Table Inheritance: Maps an entire class hierarchy to a single database table with all fields, simplifying database structure but potentially complicating queries.","Special Case: Uses a specific object to handle edge cases (e.g., null or default behavior), reducing conditional logic in the codebase.","Table Data Gateway: Provides a single object to handle all database operations for a table, simplifying data access for straightforward applications.","Table Module: Organizes business logic around database tables, with one module per table, suitable for simpler applications with table-centric logic.","Template View: Renders dynamic content by embedding logic in a presentation template, balancing simplicity and flexibility for web applications.","Transaction Script: Organizes business logic as a single procedure or script for each use case, suitable for simple applications with minimal complexity.","Transform View: Processes data into a specific format (e.g., HTML or XML) using a transformation pipeline, useful for rendering complex outputs.","Two-Step View: Separates view rendering into two stages—logic to structure data and a template to format it—improving reusability in presentation logic.","Unit of Work: Tracks changes to objects during a transaction and commits them to the database as a single unit, simplifying persistence and ensuring consistency.","Value Object: Represents a small, immutable object with no identity (e.g., a date or money amount), simplifying data handling and ensuring consistency."]}],[{"l":"Patterns from Enterprise Integration Patterns by Gregor Hohpe and Bobby Woolf","p":["Aggregator: Combines multiple related messages into a single message based on a correlation strategy, enabling processing of aggregated data.","Below is a bullet list of the 65 patterns from Enterprise Integration Patterns: Designing, Building, and Deploying Messaging Solutions by Gregor Hohpe and Bobby Woolf (2003). Each pattern includes its name and a brief description of its purpose, focusing on solutions for enterprise application integration using messaging.","Canonical Data Model: Defines a standard data format for messages to ensure consistency across different systems, reducing transformation complexity.","Channel Adapter: Connects an application to a messaging system by adapting its API to the messaging infrastructure, enabling seamless integration.","Channel Purger: Removes all messages from a channel for testing or cleanup, ensuring a clean slate for message processing.","Claim Check: Stores large message payloads in a persistent store and sends a reference (claim check) in the message, reducing message size.","Command Message: Represents a command to invoke a specific operation on a receiver, enabling remote procedure calls via messaging.","Competing Consumers: Allows multiple consumers to process messages from a single queue concurrently, improving throughput and scalability.","Content Enricher: Adds missing data to a message by retrieving it from an external source, ensuring the message contains all required information.","Content Filter: Removes unnecessary or sensitive data from a message, reducing its size and simplifying downstream processing.","Content-Based Router: Routes a message to different youre a destination based on its content, enabling dynamic message routing.","Control Bus: Uses a dedicated channel to send control messages that manage or monitor the messaging system, ensuring operational control.","Correlation Identifier: Assigns a unique ID to a message to track related messages across multiple channels or systems, enabling message correlation.","Databank Channel: Stores messages in a database-like channel for later retrieval, supporting asynchronous or delayed processing.","Dead Letter Channel: Sends undeliverable or unprocessed messages to a special channel for error handling or manual inspection.","Document Message: Represents a document (data) without specific processing instructions, allowing flexible handling by the receiver.","Durable Subscriber: Ensures a subscriber receives all messages, even those sent while disconnected, by storing them until delivery.","Dynamic Router: Routes messages to destinations based on dynamically updated routing rules, providing flexible routing logic.","Envelope Wrapper: Wraps a message in an envelope with additional metadata (e.g., headers), enabling standardized message handling.","Event Message: Notifies subscribers of an event without expecting a response, enabling decoupled event-driven communication.","Event-Driven Consumer: Triggers message processing when a message arrives, eliminating the need for polling and improving responsiveness.","File Transfer: Moves files between systems without using messaging channels, providing a simple integration method for file-based systems.","Filter: Discards messages that don’t meet specific criteria, preventing unnecessary processing by downstream components.","Format Indicator: Includes metadata to indicate the message’s data format, enabling correct interpretation by the receiver.","Guaranteed Delivery: Ensures messages are delivered despite failures by using persistent storage and retry mechanisms.","Idempotent Receiver: Ignores duplicate messages to prevent reprocessing, ensuring safe message handling in unreliable systems.","Message Bus: Transports messages between multiple components or applications, acting as a central communication backbone.","Message Channel: Connects a sender and receiver for message exchange, providing a conduit for asynchronous communication.","Message Dispatcher: Routes messages from a single channel to multiple consumers based on workload, enabling load balancing.","Message Endpoint: Connects an application to a messaging system as a sender or receiver, facilitating integration.","Message Expiration: Sets a time limit for a message’s validity, discarding it if undelivered or unprocessed in time.","Message Filter: Filters messages based on criteria, allowing only relevant messages to proceed to the receiver.","Message History: Attaches a history of processing steps to a message, enabling tracking and debugging of message flow.","Message Sequence: Ensures messages are processed in a specific order by using sequence identifiers, maintaining logical order.","Message Store: Persists messages in a database for auditing, recovery, or delayed processing, ensuring reliability.","Message Translator: Converts a message’s format or structure to match the receiver’s requirements, enabling interoperability.","Message: Encapsulates data and metadata for transmission between systems, enabling standardized communication.","Messaging Bridge: Connects two different messaging systems, allowing messages to flow between disparate platforms.","Messaging Gateway: Encapsulates messaging system access within an application, simplifying interaction with the messaging infrastructure.","Normaliser: Transforms messages of different formats into a common format, simplifying downstream processing.","Pipes and Filters: Breaks down message processing into a series of independent filter components connected by pipes, enabling modular processing.","Point-to-Point Channel: Delivers a message to a single receiver, ensuring direct and exclusive communication.","Polling Consumer: Periodically checks a channel for new messages, enabling message retrieval in systems without event-driven support.","Process Manager: Orchestrates a multi-step process by routing messages between components, managing complex workflows.","Publish-Subscribe Channel: Broadcasts a message to all subscribers of a channel, enabling one-to-many communication.","Recipient List: Sends a message to a dynamically determined list of recipients, enabling flexible multicast distribution.","Request-Reply: Sends a request message and expects a reply, enabling synchronous-like communication over asynchronous messaging.","Resequencer: Reorders messages that arrive out of sequence, ensuring they are processed in the correct order.","Return Address: Specifies the reply channel in a request message, directing where the response should be sent.","Routing Slip: Attaches a predefined list of processing steps to a message, guiding it through a specific sequence of components.","Scatter-Gather: Sends a message to multiple recipients and aggregates their responses into a single result, enabling parallel processing.","Selective Consumer: Filters messages to process only those meeting specific criteria, reducing unnecessary processing.","Service Activator: Triggers a service or application in response to a message, connecting messaging to business logic.","Shared Database: Enables integration by having multiple applications access a common database, simplifying data sharing.","Smart Proxy: Intercepts messages to monitor or modify their flow without altering the core messaging system, enabling tracking or control.","Splitter: Breaks a composite message into individual messages for separate processing, enabling fine-grained handling.","Test Message: Sends a test message through the system to verify functionality or diagnose issues, ensuring system reliability.","Transactional Client: Ensures message sending or receiving is part of a transaction, guaranteeing atomicity and consistency.","Wire Tap: Copies messages to a secondary channel for monitoring or auditing without affecting the primary flow, enabling observability."]}],[{"l":"Refactoring Patterns from Martin Fowler's Refactoring","p":["Add Parameter: Introduce a new parameter to a method to pass additional data needed for its functionality, improving flexibility without altering the method's core logic.","Below is a bullet list of refactoring patterns from Martin Fowler's book Refactoring: Improving the Design of Existing Code(2nd Edition). Each pattern includes its name and a brief description of its purpose.","Change Bidirectional Association to Unidirectional: Convert a two-way relationship between classes to a one-way relationship to reduce coupling and simplify dependencies.","Change Reference to Value: Replace a reference object with a value object when the object is immutable and small, improving performance and reducing complexity.","Change Unidirectional Association to Bidirectional: Add a back-reference to create a two-way relationship between classes, enabling easier navigation and consistency.","Change Value to Reference: Convert a value object to a reference object when multiple parts of the code need to share the same instance, ensuring consistency.","Collapse Hierarchy: Merge a superclass and its subclass into a single class when they share similar responsibilities, reducing unnecessary complexity.","Consolidate Conditional Expression: Combine multiple related conditional checks into a single expression to improve readability and reduce duplication.","Consolidate Duplicate Conditional Fragments: Move identical code fragments shared across conditional branches outside the conditional to eliminate redundancy.","Convert Procedural Design to Objects: Transform procedural code into an object-oriented design by grouping related data and behavior into classes, improving modularity.","Decompose Conditional: Break a complex conditional statement into smaller, named methods to clarify the logic and improve readability.","Duplicate Observed Data: Copy data from a domain model to a separate presentation model to decouple the UI from the business logic, often used in layered architectures.","Encapsulate Collection: Restrict direct access to a collection by providing methods to manipulate it, ensuring better control and consistency.","Encapsulate Downcast: Replace explicit downcasting with a method that returns the correct type, improving type safety and code clarity.","Encapsulate Field: Make a public field private and provide getter/setter methods to control access and improve encapsulation.","Extract Class: Move a subset of fields and methods from a large class into a new class to improve cohesion and reduce class size.","Extract Function: Move a block of code into a separate function with a descriptive name to improve readability and reusability.","Extract Interface: Create an interface from a class’s methods to define a contract, allowing multiple implementations and improving flexibility.","Extract Module: Move related functions and data into a separate module or namespace to organize code better and reduce global scope pollution.","Extract Subclass: Create a subclass to handle specific behavior variations, improving separation of concerns in a class hierarchy.","Extract Superclass: Move common fields and methods from related classes into a shared superclass to eliminate duplication and improve structure.","Extract Variable: Assign a complex expression to a named variable to improve code clarity and make debugging easier.","Form Template Method: Move varying steps of an algorithm to subclasses while keeping the common structure in a superclass, reducing duplication in similar methods.","Hide Delegate: Encapsulate access to a delegate object by providing methods in the client class, reducing coupling and simplifying interactions.","Hide Method: Make a public method private or protected when it’s only used internally, improving encapsulation and reducing the public API.","Inline Class: Merge a class’s responsibilities into another class when it no longer justifies its existence, simplifying the codebase.","Inline Function: Replace a function call with its body when the function is simple or only called once, reducing overhead and improving clarity.","Inline Temp: Replace a temporary variable with its expression when it adds no clarity, simplifying the code.","Introduce Assertion: Add an explicit check to verify assumptions in the code, improving reliability and catching errors early.","Introduce Foreign Method: Add a utility method to a class from another module or library when you can’t modify the original class, improving code organization.","Introduce Local Extension: Create a subclass or wrapper to add new behavior to an unmodifiable class, providing a clean way to extend functionality.","Introduce Null Object: Replace null checks with an object that implements the same interface but does nothing, simplifying conditional logic.","Introduce Parameter Object: Group related parameters into a single object to simplify method signatures and improve data cohesion.","Move Field: Relocate a field from one class to another when it’s more closely related to the target class’s responsibilities, improving cohesion.","Move Function: Relocate a function to the class or module where it’s most relevant, improving organization and reducing coupling.","Move Statements into Function: Move repeated statements into a function to reduce duplication and improve maintainability.","Move Statements to Callers: Move statements out of a function to its callers when they’re specific to certain use cases, improving function generality.","Parameterize Function: Generalize a function by adding parameters to handle variations, reducing the need for similar functions.","Preserve Whole Object: Pass an entire object to a method instead of multiple individual fields, simplifying the interface and improving cohesion.","Pull Up Constructor Body: Move common constructor logic from subclasses to the superclass to reduce duplication and ensure consistency.","Pull Up Field: Move a field from subclasses to a superclass when it’s used identically across them, reducing duplication.","Pull Up Method: Move a method from subclasses to a superclass when it’s identical or nearly identical, eliminating duplication.","Push Down Field: Move a field from a superclass to subclasses when it’s only relevant to some subclasses, improving specialization.","Push Down Method: Move a method from a superclass to subclasses when it’s only relevant to some subclasses, improving clarity.","Remove Assignments to Parameters: Avoid modifying parameter values within a method by using local variables instead, improving clarity and safety.","Remove Dead Code: Eliminate code that’s no longer used to reduce clutter and improve maintainability.","Remove Flag Argument: Replace a boolean parameter that controls behavior with separate methods, improving clarity and reducing complexity.","Remove Middle Man: Eliminate unnecessary delegation methods to directly access a delegate object, reducing indirection when appropriate.","Remove Subclass: Eliminate a subclass when its differences are minimal, merging its behavior into the superclass or another class.","Rename Field: Change a field’s name to better reflect its purpose, improving code readability and maintainability.","Rename Function: Change a function’s name to better describe its purpose, improving code clarity and intent.","Rename Variable: Change a variable’s name to make its purpose clearer, improving readability and maintainability.","Replace Conditional with Polymorphism: Use subclasses or polymorphic behavior to handle conditionals, simplifying logic and improving extensibility.","Replace Constructor with Factory Function: Replace a constructor with a factory function to provide more flexibility in object creation.","Replace Derived Variable with Query: Replace a variable that stores a computed value with a method that calculates it, ensuring up-to-date values.","Replace Exception with Precheck: Replace exception handling with a precondition check to simplify control flow and improve performance.","Replace Function with Command: Convert a function into a command object to encapsulate complex logic or support undoable operations.","Replace Inline Code with Function Call: Replace inline code with a call to an existing or new function to improve reusability and clarity.","Replace Loop with Pipeline: Convert a loop into a pipeline of operations (e.g., using map, filter, reduce) to improve readability and functional style.","Replace Nested Conditional with Guard Clauses: Use early returns (guard clauses) to simplify nested conditionals, improving readability.","Replace Parameter with Query: Replace a parameter with a method call to compute its value, reducing parameter lists and improving encapsulation.","Replace Primitive with Object: Replace a primitive type with a rich object to encapsulate behavior and improve type safety.","Replace Subclass with Fields: Eliminate a subclass by moving its distinguishing fields to the superclass, simplifying the hierarchy when polymorphism isn’t needed.","Replace Temp with Query: Replace a temporary variable with a method that computes its value, reducing variable scope and improving clarity.","Replace Type Code with State/Strategy: Replace a type code with a state or strategy pattern to encapsulate behavior variations, improving flexibility.","Replace Type Code with Subclasses: Use subclasses to represent type codes, enabling polymorphic behavior and improving extensibility.","Separate Query from Modifier: Split a method that both queries and modifies state into two methods, improving clarity and safety.","Slide Statements: Reorder statements to group related code together, improving readability and preparing for further refactoring.","Split Loop: Break a loop that performs multiple tasks into separate loops for each task, improving clarity and maintainability.","Split Phase: Divide a process into distinct phases with clear inputs and outputs, improving modularity and testability.","Split Variable: Split a variable used for multiple purposes into separate variables, improving clarity and reducing errors.","Substitute Algorithm: Replace an algorithm with a simpler or more efficient one, improving performance or readability.","Unify Interfaces with Adapter: Use an adapter to make classes with similar responsibilities share a common interface, improving consistency and interchangeability."]}],[{"l":"Installation","p":["Coming Soon"]}],[{"l":"Configuration"}],[{"l":"Aliases"}],[{"l":"Recipes"}],[{"l":"Conventional Commits","p":["Conventional Commits is specification for adding human and machine readable meaning to commit messages."]},{"l":"Commit Message Structure"},{"l":"Commit Types","p":["A bug fix","A code change that improves performance","A code change that neither fixes a bug nor adds a feature","A new feature","Adding missing tests or correcting existing tests","build","Changes that affect the build system or external dependencies (example scopes: gulp, broccoli, npm)","Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc)","Changes to CI configuration files and scripts (example scopes: Travis, Circle, BrowserStack, SauceLabs)","Changes which doesn't change source code or tests e.g. changes to the build process, auxiliary tools, libraries","chore","ci","Commit Type","Description","docs","Documentation only changes","feat","fix","perf","refactor","revert","Revert something","style","test"]},{"l":"Examples"},{"l":"Specification","p":["The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.","Commits MUST be prefixed with a type, which consists of a noun, feat, fix, etc., followed by a colon and a space.","The type feat MUST be used when a commit adds a new feature to your application or library.","The type fix MUST be used when a commit represents a bug fix for your application.","An optional scope MAY be provided after a type. A scope is a phrase describing a section of the codebase enclosed in parenthesis, e.g., fix(parser):","A description MUST immediately follow the type/scope prefix. The description is a short description of the code changes, e.g., fix: array parsing issue when multiple spaces were contained in string.","A longer commit body MAY be provided after the short description, providing additional contextual information about the code changes. The body MUST begin one blank line after the description.","A footer MAY be provided one blank line after the body. The footer SHOULD contain additional issue references about the code changes (such as the issues it fixes, e.g., Fixes #13).","Breaking changes MUST be indicated in the footer AND by appending a ! after the type/scope. A BREAKING CHANGE introduces a breaking API change (correlating with MAJOR in Semantic Versioning). A BREAKING CHANGE can be part of commits of any type.","A description MUST be provided after the BREAKING CHANGE:, describing what has changed about the API, e.g., BREAKING CHANGE: environment variables now take precedence over config files.","The footer MUST only contain BREAKING CHANGE, external links, issue references, and other meta-information.","Types other than feat and fix MAY be used in your commit messages."]}],[{"l":"Overview","p":["https://www.c-sharpcorner.com/article/how-to-use-ngrok-in-asp-net-core"]}],[{"l":".Net CLI"}],[{"l":"Overview"}],[{"l":"Blog"}],[{"l":"This is a good post"}],[{"l":"Tailwind 4 with Asp.Net"}]]