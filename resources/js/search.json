[[{"l":"Index"}],[{"l":"Welcome","p":["This site is not ready for public consumption. Rough outlines are being created, many times with the help of AI. I'm building this in public and will continuously refine and fill in the gaps.","Feel free to look around, but expect most topics to just be rough drafts or placeholders for later completion"]}],[{"l":"Workstation Setup"},{"l":"Desktop","p":["You are going to be looking at your desktop a lot, so pick a background that brings you happiness. Every time you look at it you should feel joy and excitement. I use the following background that I found from https://www.youtube.com/@typecraft_dev"]},{"l":"Terminal","p":["Coming Soon"]}],[{"l":"Software Development Lifecycle (SDLC) Steps","p":["The Software Development Lifecycle (SDLC) is a structured process for planning, creating, testing, deploying, and maintaining software. Below is a comprehensive list of SDLC phases, each with a brief description of its purpose and activities."]},{"l":"1. Requirement Analysis","p":["Description: Gather and analyze project requirements to define the scope and objectives.","Collaborate with stakeholders (clients, end-users, management) to understand needs.","Document functional and non-functional requirements (e.g., features, performance, security).","Create requirement specifications, user stories, or use cases.","Validate requirements to ensure clarity, feasibility, and alignment with business goals."]},{"l":"2. Feasibility Study","p":["Description: Assess the project's viability from technical, financial, and operational perspectives.","Evaluate technical feasibility (e.g., available technology, expertise).","Analyze cost-benefit and resource requirements.","Identify risks and constraints (e.g., time, budget, technology limitations).","Produce a feasibility report to guide decision-making."]},{"l":"3. System Design","p":["Description: Create a blueprint for the software system based on requirements.","Define system architecture (e.g., monolithic, microservices, cloud-based).","Design components, modules, databases, and interfaces.","Specify tools, frameworks, and technologies to be used.","Create detailed design documents, including flowcharts, ER diagrams, and wireframes."]},{"l":"4. Development (Coding)","p":["Description: Write code to implement the system design.","Assign tasks to developers based on design specifications.","Use programming languages, frameworks, and tools to build software components.","Follow coding standards and best practices (e.g., modularity, documentation).","Conduct regular code reviews to ensure quality and consistency."]},{"l":"5. Testing","p":["Description: Verify that the software meets requirements and is free of defects.","Perform unit testing to validate individual components.","Conduct integration testing to ensure modules work together.","Execute system testing to verify the entire system’s functionality.","Perform user acceptance testing (UAT) to confirm the software meets user needs.","Identify and fix bugs, ensuring performance, security, and usability."]},{"l":"6. Deployment","p":["Description: Release the software to the production environment for end-user access.","Plan deployment strategy (e.g., phased rollout, big bang).","Set up production environments (servers, databases, configurations).","Deploy the software using automated tools or manual processes.","Monitor initial performance and address any immediate issues."]},{"l":"7. Maintenance","p":["Description: Provide ongoing support to ensure the software remains functional and relevant.","Monitor system performance and address issues (e.g., bugs, crashes).","Release updates or patches to fix defects or improve functionality.","Incorporate user feedback to enhance features or usability.","Plan for scalability, security updates, and compatibility with new technologies."]},{"l":"8. Retirement (Optional)","p":["Description: Decommission the software when it becomes obsolete or is replaced.","Plan for data migration to new systems if needed.","Archive code, documentation, and data for compliance or future reference.","Notify users and stakeholders of the software’s end-of-life.","Safely shut down the system and dispose of resources."]}],[{"l":"Overview","p":["The \"Gang of Four\" design patterns, from the book Design Patterns: Elements of Reusable Object-Oriented Software by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides, are 23 classic software design patterns. They are categorized into three groups: Creational, Structural, and Behavioral. Below is a bullet list with each pattern's category, name, and a brief description of its purpose."]},{"l":"Creational Patterns","p":["Abstract Factory: Provides an interface for creating families of related or dependent objects without specifying their concrete classes.","Builder: Separates the construction of a complex object from its representation, allowing the same construction process to create different representations.","Factory Method: Defines an interface for creating an object, but lets subclasses decide which class to instantiate.","Prototype: Creates new objects by copying an existing object, known as the prototype, to avoid the overhead of initializing from scratch.","Singleton: Ensures a class has only one instance and provides a global point of access to it."]},{"l":"Structural Patterns","p":["Adapter: Converts the interface of a class into another interface that a client expects, enabling incompatible classes to work together.","Bridge: Decouples an abstraction from its implementation so that the two can vary independently.","Composite: Composes objects into tree structures to represent part-whole hierarchies, allowing clients to treat individual objects and compositions uniformly.","Decorator: Dynamically adds responsibilities to objects in a flexible and reusable way without modifying their code.","Facade: Provides a simplified interface to a complex subsystem, making it easier to use.","Flyweight: Shares fine-grained objects to reduce memory usage and improve performance when dealing with large numbers of similar objects.","Proxy: Controls access to an object by acting as a surrogate or placeholder, often to add functionality like lazy loading or access control."]},{"l":"Behavioral Patterns","p":["Chain of Responsibility: Passes a request along a chain of handlers, allowing each handler to process it or pass it to the next handler.","Command: Encapsulates a request as an object, allowing parameterization of clients with queues, logs, or undoable operations.","Interpreter: Defines a representation for a language's grammar and an interpreter to process expressions in that language.","Iterator: Provides a way to access elements of a collection sequentially without exposing its underlying representation.","Mediator: Defines an object that encapsulates how a set of objects interact, promoting loose coupling by preventing direct references.","Memento: Captures and externalizes an object's internal state so that it can be restored later without violating encapsulation.","Observer: Defines a one-to-many dependency where objects are notified and updated automatically when one object changes state.","State: Allows an object to change its behavior when its internal state changes, appearing as if it changes its class.","Strategy: Defines a family of algorithms, encapsulates each one, and makes them interchangeable, letting the client choose the algorithm at runtime.","Template Method: Defines the skeleton of an algorithm in a method, deferring some steps to subclasses to customize behavior.","Visitor: Separates an algorithm from an object structure by moving the operations to a visitor object, allowing new operations without modifying the structure."]}],[{"l":"Abstract factory pattern"}],[{"l":"Builder pattern"}],[{"l":"Factory method pattern"}],[{"l":"Prototype pattern"}],[{"l":"Singleton pattern"}],[{"l":"Patterns from Martin Fowler's Patterns of Enterprise Application Architecture","p":["Active Record: Encapsulates database access by integrating data and behavior into a single object, where each object corresponds to a database row, simplifying CRUD operations.","Association Table Mapping: Maps an association between two objects to a database table, enabling flexible relationships like many-to-many links in relational databases.","Below is a bullet list of patterns from Martin Fowler's book Patterns of Enterprise Application Architecture(2002). Each pattern includes its name and a brief description of its purpose, based on the book's catalog of solutions for common enterprise application challenges.","Class Table Inheritance: Represents a class hierarchy in a database by creating a table for each class, with shared data in a parent table, supporting inheritance in object-oriented designs.","Coarse-Grained Lock: Locks a group of related objects as a single unit to prevent concurrent modifications, simplifying concurrency control in complex data structures.","Concrete Table Inheritance: Maps each class in a hierarchy to its own database table containing all fields, simplifying queries but potentially duplicating data.","Data Mapper: Separates domain objects from database access logic by using a mapper class to handle data transfer, decoupling the object model from the database schema.","Data Transfer Object: Packages data into a single object to reduce the number of method calls across system boundaries, improving performance in distributed systems.","Dependent Mapping: Delegates the mapping of an object’s fields to another object (e.g., a parent object), reducing redundancy in mapping logic for related objects.","Domain Model: Organizes business logic into a rich object model with behavior and data, enabling complex domain logic while keeping it independent of persistence.","Embedded Value: Stores a small, dependent object’s data directly within its parent’s table, simplifying storage for simple value objects without needing separate tables.","Foreign Key Mapping: Uses foreign keys in a database to represent relationships between objects, enabling navigation and maintaining referential integrity.","Front Controller: Centralizes request handling through a single controller to manage web requests, ensuring consistent processing and reducing duplication in web applications.","Gateway: Encapsulates access to an external system or resource (e.g., a database or service) through a simple interface, simplifying interaction and isolating external dependencies.","Identity Field: Adds a unique field (e.g., a primary key) to an object to map it to a database record, ensuring consistent identification across layers.","Identity Map: Maintains a cache of objects by their identity to ensure each database record is loaded only once, preventing duplicate objects and improving performance.","Implicit Lock: Manages concurrency by automatically applying locks during transactions, simplifying locking logic for developers but potentially reducing flexibility.","Inheritance Mappers: Uses separate mapper classes for each class in an inheritance hierarchy to handle persistence, supporting complex object hierarchies.","Layer Supertype: Provides a common superclass for all objects in a layer to share common behavior, reducing duplication across similar objects in a layer.","Lazy Load: Delays loading of an object’s data until it’s needed, improving performance by reducing unnecessary database queries.","Metadata Mapping: Stores mapping information (e.g., between objects and database tables) in metadata, enabling flexible and configurable persistence logic.","Model View Controller: Separates application concerns into models (data and logic), views (UI), and controllers (input handling), improving modularity and testability.","Money: Represents monetary values with a specific currency and handles arithmetic and rounding, ensuring accurate financial calculations.","Optimistic Offline Lock: Allows concurrent access to data by checking for conflicts only at commit time, improving performance in low-conflict scenarios.","Page Controller: Handles web requests for a specific page or action with a dedicated controller, simplifying handling for straightforward web applications.","Plugin: Enables dynamic loading of components or modules at runtime, improving extensibility and configurability of applications.","Query Object: Encapsulates a database query as an object, allowing complex queries to be built and reused while keeping persistence logic separate.","Record Set: Represents tabular data (e.g., query results) as an in-memory structure, providing a flexible way to manipulate data in applications.","Registry: Provides a central point to access commonly used objects or services, simplifying access and reducing coupling across the system.","Remote Facade: Exposes a coarse-grained interface to hide the complexity of a fine-grained object model, improving performance in distributed systems.","Repository: Centralizes data access logic for a domain type, providing a collection-like interface to query and manage domain objects.","Row Data Gateway: Represents a single database row as an object with fields and access methods, simplifying data access for simple applications.","Separated Interface: Defines an interface in a separate package from its implementation to reduce coupling and allow multiple implementations.","Serialized LOB: Stores a large object (LOB), like a complex object graph, as a serialized blob in a database, simplifying storage of complex data.","Service Layer: Centralizes business logic into a distinct layer that coordinates operations across domain objects, improving maintainability and modularity.","Service Stub: Replaces an external service with a simplified version for testing or development, isolating the system from external dependencies.","Session State: Manages user session data (e.g., in web applications) to maintain state between requests, supporting user-specific interactions.","Single Table Inheritance: Maps an entire class hierarchy to a single database table with all fields, simplifying database structure but potentially complicating queries.","Special Case: Uses a specific object to handle edge cases (e.g., null or default behavior), reducing conditional logic in the codebase.","Table Data Gateway: Provides a single object to handle all database operations for a table, simplifying data access for straightforward applications.","Table Module: Organizes business logic around database tables, with one module per table, suitable for simpler applications with table-centric logic.","Template View: Renders dynamic content by embedding logic in a presentation template, balancing simplicity and flexibility for web applications.","Transaction Script: Organizes business logic as a single procedure or script for each use case, suitable for simple applications with minimal complexity.","Transform View: Processes data into a specific format (e.g., HTML or XML) using a transformation pipeline, useful for rendering complex outputs.","Two-Step View: Separates view rendering into two stages—logic to structure data and a template to format it—improving reusability in presentation logic.","Unit of Work: Tracks changes to objects during a transaction and commits them to the database as a single unit, simplifying persistence and ensuring consistency.","Value Object: Represents a small, immutable object with no identity (e.g., a date or money amount), simplifying data handling and ensuring consistency."]}],[{"l":"Patterns from Enterprise Integration Patterns by Gregor Hohpe and Bobby Woolf","p":["Aggregator: Combines multiple related messages into a single message based on a correlation strategy, enabling processing of aggregated data.","Below is a bullet list of the 65 patterns from Enterprise Integration Patterns: Designing, Building, and Deploying Messaging Solutions by Gregor Hohpe and Bobby Woolf (2003). Each pattern includes its name and a brief description of its purpose, focusing on solutions for enterprise application integration using messaging.","Canonical Data Model: Defines a standard data format for messages to ensure consistency across different systems, reducing transformation complexity.","Channel Adapter: Connects an application to a messaging system by adapting its API to the messaging infrastructure, enabling seamless integration.","Channel Purger: Removes all messages from a channel for testing or cleanup, ensuring a clean slate for message processing.","Claim Check: Stores large message payloads in a persistent store and sends a reference (claim check) in the message, reducing message size.","Command Message: Represents a command to invoke a specific operation on a receiver, enabling remote procedure calls via messaging.","Competing Consumers: Allows multiple consumers to process messages from a single queue concurrently, improving throughput and scalability.","Content Enricher: Adds missing data to a message by retrieving it from an external source, ensuring the message contains all required information.","Content Filter: Removes unnecessary or sensitive data from a message, reducing its size and simplifying downstream processing.","Content-Based Router: Routes a message to different youre a destination based on its content, enabling dynamic message routing.","Control Bus: Uses a dedicated channel to send control messages that manage or monitor the messaging system, ensuring operational control.","Correlation Identifier: Assigns a unique ID to a message to track related messages across multiple channels or systems, enabling message correlation.","Databank Channel: Stores messages in a database-like channel for later retrieval, supporting asynchronous or delayed processing.","Dead Letter Channel: Sends undeliverable or unprocessed messages to a special channel for error handling or manual inspection.","Document Message: Represents a document (data) without specific processing instructions, allowing flexible handling by the receiver.","Durable Subscriber: Ensures a subscriber receives all messages, even those sent while disconnected, by storing them until delivery.","Dynamic Router: Routes messages to destinations based on dynamically updated routing rules, providing flexible routing logic.","Envelope Wrapper: Wraps a message in an envelope with additional metadata (e.g., headers), enabling standardized message handling.","Event Message: Notifies subscribers of an event without expecting a response, enabling decoupled event-driven communication.","Event-Driven Consumer: Triggers message processing when a message arrives, eliminating the need for polling and improving responsiveness.","File Transfer: Moves files between systems without using messaging channels, providing a simple integration method for file-based systems.","Filter: Discards messages that don’t meet specific criteria, preventing unnecessary processing by downstream components.","Format Indicator: Includes metadata to indicate the message’s data format, enabling correct interpretation by the receiver.","Guaranteed Delivery: Ensures messages are delivered despite failures by using persistent storage and retry mechanisms.","Idempotent Receiver: Ignores duplicate messages to prevent reprocessing, ensuring safe message handling in unreliable systems.","Message Bus: Transports messages between multiple components or applications, acting as a central communication backbone.","Message Channel: Connects a sender and receiver for message exchange, providing a conduit for asynchronous communication.","Message Dispatcher: Routes messages from a single channel to multiple consumers based on workload, enabling load balancing.","Message Endpoint: Connects an application to a messaging system as a sender or receiver, facilitating integration.","Message Expiration: Sets a time limit for a message’s validity, discarding it if undelivered or unprocessed in time.","Message Filter: Filters messages based on criteria, allowing only relevant messages to proceed to the receiver.","Message History: Attaches a history of processing steps to a message, enabling tracking and debugging of message flow.","Message Sequence: Ensures messages are processed in a specific order by using sequence identifiers, maintaining logical order.","Message Store: Persists messages in a database for auditing, recovery, or delayed processing, ensuring reliability.","Message Translator: Converts a message’s format or structure to match the receiver’s requirements, enabling interoperability.","Message: Encapsulates data and metadata for transmission between systems, enabling standardized communication.","Messaging Bridge: Connects two different messaging systems, allowing messages to flow between disparate platforms.","Messaging Gateway: Encapsulates messaging system access within an application, simplifying interaction with the messaging infrastructure.","Normaliser: Transforms messages of different formats into a common format, simplifying downstream processing.","Pipes and Filters: Breaks down message processing into a series of independent filter components connected by pipes, enabling modular processing.","Point-to-Point Channel: Delivers a message to a single receiver, ensuring direct and exclusive communication.","Polling Consumer: Periodically checks a channel for new messages, enabling message retrieval in systems without event-driven support.","Process Manager: Orchestrates a multi-step process by routing messages between components, managing complex workflows.","Publish-Subscribe Channel: Broadcasts a message to all subscribers of a channel, enabling one-to-many communication.","Recipient List: Sends a message to a dynamically determined list of recipients, enabling flexible multicast distribution.","Request-Reply: Sends a request message and expects a reply, enabling synchronous-like communication over asynchronous messaging.","Resequencer: Reorders messages that arrive out of sequence, ensuring they are processed in the correct order.","Return Address: Specifies the reply channel in a request message, directing where the response should be sent.","Routing Slip: Attaches a predefined list of processing steps to a message, guiding it through a specific sequence of components.","Scatter-Gather: Sends a message to multiple recipients and aggregates their responses into a single result, enabling parallel processing.","Selective Consumer: Filters messages to process only those meeting specific criteria, reducing unnecessary processing.","Service Activator: Triggers a service or application in response to a message, connecting messaging to business logic.","Shared Database: Enables integration by having multiple applications access a common database, simplifying data sharing.","Smart Proxy: Intercepts messages to monitor or modify their flow without altering the core messaging system, enabling tracking or control.","Splitter: Breaks a composite message into individual messages for separate processing, enabling fine-grained handling.","Test Message: Sends a test message through the system to verify functionality or diagnose issues, ensuring system reliability.","Transactional Client: Ensures message sending or receiving is part of a transaction, guaranteeing atomicity and consistency.","Wire Tap: Copies messages to a secondary channel for monitoring or auditing without affecting the primary flow, enabling observability."]}],[{"l":"Refactoring Patterns from Martin Fowler's Refactoring","p":["Add Parameter: Introduce a new parameter to a method to pass additional data needed for its functionality, improving flexibility without altering the method's core logic.","Below is a bullet list of refactoring patterns from Martin Fowler's book Refactoring: Improving the Design of Existing Code(2nd Edition). Each pattern includes its name and a brief description of its purpose.","Change Bidirectional Association to Unidirectional: Convert a two-way relationship between classes to a one-way relationship to reduce coupling and simplify dependencies.","Change Reference to Value: Replace a reference object with a value object when the object is immutable and small, improving performance and reducing complexity.","Change Unidirectional Association to Bidirectional: Add a back-reference to create a two-way relationship between classes, enabling easier navigation and consistency.","Change Value to Reference: Convert a value object to a reference object when multiple parts of the code need to share the same instance, ensuring consistency.","Collapse Hierarchy: Merge a superclass and its subclass into a single class when they share similar responsibilities, reducing unnecessary complexity.","Consolidate Conditional Expression: Combine multiple related conditional checks into a single expression to improve readability and reduce duplication.","Consolidate Duplicate Conditional Fragments: Move identical code fragments shared across conditional branches outside the conditional to eliminate redundancy.","Convert Procedural Design to Objects: Transform procedural code into an object-oriented design by grouping related data and behavior into classes, improving modularity.","Decompose Conditional: Break a complex conditional statement into smaller, named methods to clarify the logic and improve readability.","Duplicate Observed Data: Copy data from a domain model to a separate presentation model to decouple the UI from the business logic, often used in layered architectures.","Encapsulate Collection: Restrict direct access to a collection by providing methods to manipulate it, ensuring better control and consistency.","Encapsulate Downcast: Replace explicit downcasting with a method that returns the correct type, improving type safety and code clarity.","Encapsulate Field: Make a public field private and provide getter/setter methods to control access and improve encapsulation.","Extract Class: Move a subset of fields and methods from a large class into a new class to improve cohesion and reduce class size.","Extract Function: Move a block of code into a separate function with a descriptive name to improve readability and reusability.","Extract Interface: Create an interface from a class’s methods to define a contract, allowing multiple implementations and improving flexibility.","Extract Module: Move related functions and data into a separate module or namespace to organize code better and reduce global scope pollution.","Extract Subclass: Create a subclass to handle specific behavior variations, improving separation of concerns in a class hierarchy.","Extract Superclass: Move common fields and methods from related classes into a shared superclass to eliminate duplication and improve structure.","Extract Variable: Assign a complex expression to a named variable to improve code clarity and make debugging easier.","Form Template Method: Move varying steps of an algorithm to subclasses while keeping the common structure in a superclass, reducing duplication in similar methods.","Hide Delegate: Encapsulate access to a delegate object by providing methods in the client class, reducing coupling and simplifying interactions.","Hide Method: Make a public method private or protected when it’s only used internally, improving encapsulation and reducing the public API.","Inline Class: Merge a class’s responsibilities into another class when it no longer justifies its existence, simplifying the codebase.","Inline Function: Replace a function call with its body when the function is simple or only called once, reducing overhead and improving clarity.","Inline Temp: Replace a temporary variable with its expression when it adds no clarity, simplifying the code.","Introduce Assertion: Add an explicit check to verify assumptions in the code, improving reliability and catching errors early.","Introduce Foreign Method: Add a utility method to a class from another module or library when you can’t modify the original class, improving code organization.","Introduce Local Extension: Create a subclass or wrapper to add new behavior to an unmodifiable class, providing a clean way to extend functionality.","Introduce Null Object: Replace null checks with an object that implements the same interface but does nothing, simplifying conditional logic.","Introduce Parameter Object: Group related parameters into a single object to simplify method signatures and improve data cohesion.","Move Field: Relocate a field from one class to another when it’s more closely related to the target class’s responsibilities, improving cohesion.","Move Function: Relocate a function to the class or module where it’s most relevant, improving organization and reducing coupling.","Move Statements into Function: Move repeated statements into a function to reduce duplication and improve maintainability.","Move Statements to Callers: Move statements out of a function to its callers when they’re specific to certain use cases, improving function generality.","Parameterize Function: Generalize a function by adding parameters to handle variations, reducing the need for similar functions.","Preserve Whole Object: Pass an entire object to a method instead of multiple individual fields, simplifying the interface and improving cohesion.","Pull Up Constructor Body: Move common constructor logic from subclasses to the superclass to reduce duplication and ensure consistency.","Pull Up Field: Move a field from subclasses to a superclass when it’s used identically across them, reducing duplication.","Pull Up Method: Move a method from subclasses to a superclass when it’s identical or nearly identical, eliminating duplication.","Push Down Field: Move a field from a superclass to subclasses when it’s only relevant to some subclasses, improving specialization.","Push Down Method: Move a method from a superclass to subclasses when it’s only relevant to some subclasses, improving clarity.","Remove Assignments to Parameters: Avoid modifying parameter values within a method by using local variables instead, improving clarity and safety.","Remove Dead Code: Eliminate code that’s no longer used to reduce clutter and improve maintainability.","Remove Flag Argument: Replace a boolean parameter that controls behavior with separate methods, improving clarity and reducing complexity.","Remove Middle Man: Eliminate unnecessary delegation methods to directly access a delegate object, reducing indirection when appropriate.","Remove Subclass: Eliminate a subclass when its differences are minimal, merging its behavior into the superclass or another class.","Rename Field: Change a field’s name to better reflect its purpose, improving code readability and maintainability.","Rename Function: Change a function’s name to better describe its purpose, improving code clarity and intent.","Rename Variable: Change a variable’s name to make its purpose clearer, improving readability and maintainability.","Replace Conditional with Polymorphism: Use subclasses or polymorphic behavior to handle conditionals, simplifying logic and improving extensibility.","Replace Constructor with Factory Function: Replace a constructor with a factory function to provide more flexibility in object creation.","Replace Derived Variable with Query: Replace a variable that stores a computed value with a method that calculates it, ensuring up-to-date values.","Replace Exception with Precheck: Replace exception handling with a precondition check to simplify control flow and improve performance.","Replace Function with Command: Convert a function into a command object to encapsulate complex logic or support undoable operations.","Replace Inline Code with Function Call: Replace inline code with a call to an existing or new function to improve reusability and clarity.","Replace Loop with Pipeline: Convert a loop into a pipeline of operations (e.g., using map, filter, reduce) to improve readability and functional style.","Replace Nested Conditional with Guard Clauses: Use early returns (guard clauses) to simplify nested conditionals, improving readability.","Replace Parameter with Query: Replace a parameter with a method call to compute its value, reducing parameter lists and improving encapsulation.","Replace Primitive with Object: Replace a primitive type with a rich object to encapsulate behavior and improve type safety.","Replace Subclass with Fields: Eliminate a subclass by moving its distinguishing fields to the superclass, simplifying the hierarchy when polymorphism isn’t needed.","Replace Temp with Query: Replace a temporary variable with a method that computes its value, reducing variable scope and improving clarity.","Replace Type Code with State/Strategy: Replace a type code with a state or strategy pattern to encapsulate behavior variations, improving flexibility.","Replace Type Code with Subclasses: Use subclasses to represent type codes, enabling polymorphic behavior and improving extensibility.","Separate Query from Modifier: Split a method that both queries and modifies state into two methods, improving clarity and safety.","Slide Statements: Reorder statements to group related code together, improving readability and preparing for further refactoring.","Split Loop: Break a loop that performs multiple tasks into separate loops for each task, improving clarity and maintainability.","Split Phase: Divide a process into distinct phases with clear inputs and outputs, improving modularity and testability.","Split Variable: Split a variable used for multiple purposes into separate variables, improving clarity and reducing errors.","Substitute Algorithm: Replace an algorithm with a simpler or more efficient one, improving performance or readability.","Unify Interfaces with Adapter: Use an adapter to make classes with similar responsibilities share a common interface, improving consistency and interchangeability."]}],[{"l":"Installation","p":["Coming Soon"]}],[{"l":"Configuration"}],[{"l":"Aliases"}],[{"l":"Recipes"}],[{"l":"Conventional Commits","p":["Conventional Commits is specification for adding human and machine readable meaning to commit messages."]},{"l":"Commit Message Structure"},{"l":"Commit Types","p":["A bug fix","A code change that improves performance","A code change that neither fixes a bug nor adds a feature","A new feature","Adding missing tests or correcting existing tests","build","Changes that affect the build system or external dependencies (example scopes: gulp, broccoli, npm)","Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc)","Changes to CI configuration files and scripts (example scopes: Travis, Circle, BrowserStack, SauceLabs)","Changes which doesn't change source code or tests e.g. changes to the build process, auxiliary tools, libraries","chore","ci","Commit Type","Description","docs","Documentation only changes","feat","fix","perf","refactor","revert","Revert something","style","test"]},{"l":"Examples"},{"l":"Specification","p":["The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.","Commits MUST be prefixed with a type, which consists of a noun, feat, fix, etc., followed by a colon and a space.","The type feat MUST be used when a commit adds a new feature to your application or library.","The type fix MUST be used when a commit represents a bug fix for your application.","An optional scope MAY be provided after a type. A scope is a phrase describing a section of the codebase enclosed in parenthesis, e.g., fix(parser):","A description MUST immediately follow the type/scope prefix. The description is a short description of the code changes, e.g., fix: array parsing issue when multiple spaces were contained in string.","A longer commit body MAY be provided after the short description, providing additional contextual information about the code changes. The body MUST begin one blank line after the description.","A footer MAY be provided one blank line after the body. The footer SHOULD contain additional issue references about the code changes (such as the issues it fixes, e.g., Fixes #13).","Breaking changes MUST be indicated in the footer AND by appending a ! after the type/scope. A BREAKING CHANGE introduces a breaking API change (correlating with MAJOR in Semantic Versioning). A BREAKING CHANGE can be part of commits of any type.","A description MUST be provided after the BREAKING CHANGE:, describing what has changed about the API, e.g., BREAKING CHANGE: environment variables now take precedence over config files.","The footer MUST only contain BREAKING CHANGE, external links, issue references, and other meta-information.","Types other than feat and fix MAY be used in your commit messages."]}],[{"l":"Overview","p":["https://www.c-sharpcorner.com/article/how-to-use-ngrok-in-asp-net-core"]}],[{"l":".Net CLI"}],[{"l":"Outline of C# Language Features (C# 1.0 to C# 14.0)"},{"l":"C# 1.0 (2002)","p":["Abstract classes ( abstract).","Access Modifiers","Arithmetic: +, -, *, /, %.","Arrays","Assignment: =, +=, -=, *=, /=, %=, etc.","Attributes","Automatic memory management.","Basic attribute usage ([Obsolete]).","Basic Syntax and Structure","Bitwise: , |, ^, ~, , .","Boolean type: bool( true/ false).","Boxing and unboxing ( object to/from value types).","Case-sensitive identifiers.","Character type: char(Unicode 16-bit).","Class declaration ( class MyClass {}).","Classes and Objects","Conditional statements: if, else if, else.","Constants ( const int Max = 100;).","Constructors (default and parameterized).","Control Flow","Curly braces ({}) to define code blocks.","Custom attributes (inheriting from Attribute).","Custom exceptions (inheriting from Exception).","Decimal type: decimal for precise financial calculations.","Declaring namespaces ( namespace MyApp;).","Default access (private for class members, internal for types).","Delegate declaration ( delegate void MyDelegate(int x);).","Delegates","Differences from classes (value semantics, no inheritance).","Encapsulation (using access modifiers).","Enumeration types ( enum Day { Monday, Tuesday, ... }).","Enums","Event declaration using delegates ( event MyDelegate MyEvent;).","Event handling basics (using delegates).","Events","Exception Handling","Fields, properties (basic fields, no auto-implemented properties yet).","Floating-point types: float, double.","Foundational features establishing C# as a modern, object-oriented language. These are the core building blocks required for understanding subsequent versions.","Garbage Collection","IDisposable interface and using statement for resource cleanup.","Inheritance ( class Derived : Base).","Integer types: sbyte, byte, short, ushort, int, uint, long, ulong.","Interfaces ( interface for defining contracts).","Jagged arrays ( int[][] jagged = new int[3][];).","Jump statements: break, continue, goto, return.","Logical: , ||, !.","Loops: for, while, do-while, foreach(requires arrays or IEnumerable).","Main method as program entry point ( static void Main()).","Method declaration with parameters and return types.","Method overloading (same name, different signatures).","Methods","Methods within classes.","Multidimensional arrays ( int[,] matrix = new int[3, 3];).","Namespaces","Nested namespaces.","Object instantiation ( new keyword).","Object type: object as the root of all types.","Object-Oriented Programming","Operators","out and ref parameters for passing by reference.","Parameter passing: value types by value, reference types by reference.","Polymorphism via virtual methods ( virtual, override).","Primitive Types","public, private, protected, internal.","Raising and handling events.","Relational: ==, !=, , , =, =.","Sealed classes ( sealed to prevent inheritance).","Semicolons (;) for statement termination.","Single-cast delegates for method references.","Single-dimensional arrays ( int[] numbers = new int[5];).","Single-line (//) and multi-line (/* */) comments.","String type: string(immutable Unicode sequence).","Strong typing (compile-time type checking).","Structs","Switch statement: switch with case and default.","Ternary operator: ?:.","this keyword for self-reference.","Throwing exceptions ( throw).","try, catch, finally blocks.","Type Safety and Boxing","Underlying type (default int).","Using directives ( using System;).","Value type structs ( struct Point { public int X, Y; }).","Variable declaration and initialization ( int x = 10;).","Variables and Constants","void methods."]},{"l":"C# 2.0 (2005)","p":["Anonymous Methods(Prerequisite: Delegates)","Capturing outer variables (closures).","Constraints ( where T : class, where T : struct, where T : new(), etc.).","Covariance and Contravariance for Delegates(Prerequisite: Delegates, Generics)","Different access modifiers for get and set( public int Prop { get; private set; }).","Generic classes ( class ListT {}).","Generic delegates ( delegate T FuncT(T arg);).","Generic interfaces ( interface IComparableT).","Generic methods ( T SwapT(T a, T b)).","Generics(Prerequisite: Classes, Interfaces)","HasValue and Value properties.","Inline delegate methods ( delegate(int x) { return x * 2; }).","Introduces generics, enhanced delegates, and other features building on C# 1.0’s type system and methods.","Iterators(Prerequisite: Methods, IEnumerable)","Limited covariance/contravariance for delegate types.","Null-coalescing operator (??).","Nullable Types(Prerequisite: Value Types)","NullableT for value types ( int? x = null;).","Partial Types(Prerequisite: Classes)","Property Accessor Accessibility(Prerequisite: Classes)","Shorthand syntax ( T?).","Simplifying custom IEnumerable implementations.","Splitting class definitions across files ( partial class MyClass).","static class for utility classes (all members must be static).","Static Classes(Prerequisite: Classes)","Useful for code generation (e.g., Windows Forms).","yield break to terminate iteration.","yield return for creating iterators."]},{"l":"C# 3.0 (2007)","p":["Adding methods to existing types ( static class Extensions { public static int Double(this int x) = x * 2; }).","Anonymous Types(Prerequisite: Classes, Object Initializers)","Auto-Implemented Properties(Prerequisite: Classes)","Collection initializers ( var list = new Listint { 1, 2, 3 };).","Compiler-generated backing fields.","Concise delegate syntax ( x = x * 2).","Expression lambdas and statement lambdas.","Expression Trees(Prerequisite: Lambda Expressions)","Extension Methods(Prerequisite: Static Classes, Generics)","Focuses on LINQ and functional programming features, building heavily on generics and delegates.","Immutable, compiler-generated types.","Implicitly Typed Local Variables(Prerequisite: Variables)","Keywords: from, where, select, group, join, orderby, let, etc.","Lambda Expressions(Prerequisite: Delegates, Anonymous Methods)","Must be in static classes.","Object and Collection Initializers(Prerequisite: Classes, Arrays)","Object initializers ( var p = new Point { X = 1, Y = 2 };).","partial methods in partial classes (optional implementation).","Partial Methods(Prerequisite: Partial Types)","Query Expressions (LINQ)(Prerequisite: Generics, Lambda Expressions, Extension Methods)","Query syntax ( from x in collection where x 0 select x).","Representing code as data ( ExpressionFuncint, int).","Simplified property syntax ( public int Prop { get; set; }).","Translation to method calls (e.g., Where, Select).","Used by LINQ providers.","var anon = new { Name = John, Age = 30 };.","var keyword for local variable type inference ( var x = 10;)."]},{"l":"C# 4.0 (2010)","p":["Enhances interoperability and dynamic programming, building on generics and delegates.","Dynamic Typing(Prerequisite: Object Type)","dynamic type for runtime binding ( dynamic d = 10;).","Bypasses static type checking.","Named and Optional Parameters(Prerequisite: Methods)","Optional parameters ( void Method(int x = 0)).","Named arguments ( Method(x: 5)).","Covariance and Contravariance for Generics(Prerequisite: Generics)","out for covariance ( IEnumerableout T).","in for contravariance ( IComparerin T).","Applied to interfaces and delegates.","Embedded Interop Types(Prerequisite: Classes)","Simplifies COM interop by embedding type information.","Dynamic Import(Prerequisite: Dynamic Typing)","Improved COM interop with dynamic."]},{"l":"C# 5.0 (2012)","p":["Focuses on asynchronous programming, building on methods and delegates.","Async and Await(Prerequisite: Methods, Delegates)","async modifier for methods.","await for asynchronous operations ( await Task.Delay(1000);).","Task-based asynchronous pattern (TAP).","Caller Information Attributes(Prerequisite: Attributes)","[CallerMemberName], [CallerFilePath], [CallerLineNumber].","For logging and diagnostics."]},{"l":"C# 6.0 (2015)","p":["?. and ?[] for safe navigation ( obj?.Property).","$Hello {name} for formatted strings.","Auto-Property Initializers(Prerequisite: Auto-Implemented Properties)","Better compiler handling of ambiguous overloads.","catch (Exception ex) when (ex.Message.Contains(specific)).","Dictionary Initializers(Prerequisite: Collection Initializers)","Exception Filters(Prerequisite: Exception Handling)","Expression-Bodied Members(Prerequisite: Methods, Properties)","Expression-bodied methods ( int Double(int x) = x * 2;).","Expression-bodied properties ( int Prop = 42;).","Improved Overload Resolution(Prerequisite: Method Overloading)","Introduces syntactic sugar and developer productivity features, building on prior constructs.","nameof Operator(Prerequisite: Variables)","nameof(variable) for retrieving variable names as strings.","Null-Conditional Operator(Prerequisite: Nullable Types)","public int Prop { get; set; } = 42;.","Static Using Directives(Prerequisite: Namespaces)","String Interpolation(Prerequisite: Strings)","using static System.Math; for direct access to static members ( Sin(x)).","var dict = new Dictionaryint, string { [1] = One, [2] = Two };."]},{"l":"C# 7.0 (2017)","p":["Binary literals ( 0b1010).","Binary Literals and Digit Separators(Prerequisite: Primitive Types)","Deconstruction ((int x, string y) = t;).","Digit separators ( 1_000_000).","Enhances functionality with tuples, pattern matching, and more, building on types and control flow.","Generalized Async Return Types(Prerequisite: Async/Await)","Inline out declarations ( if (int.TryParse(s, out int result))).","is operator with type patterns ( if (obj is int i)).","Local Functions(Prerequisite: Methods)","Methods defined inside other methods ( void Local() { ... }).","Named tuple elements ( var t = (Count: 42, Name: test);).","Out Variables(Prerequisite: out Parameters)","Pattern Matching(Prerequisite: Control Flow)","ref locals ( ref int x = ref arr[0];).","ref returns ( ref int GetRef(int[] arr) = ref arr[0];).","Ref Returns and Locals(Prerequisite: ref Parameters)","Switch statement enhancements with patterns ( case int i when i 0:).","Throw Expressions(Prerequisite: Exception Handling)","Throwing in expressions ( x ?? throw new Exception()).","Tuples(Prerequisite: Types)","Value tuple syntax ((int, string) t = (42, test);).","ValueTaskT for efficient async returns."]},{"l":"C# 7.1 (2017)","p":["Minor refinements, building on C# 7.0 features.","Async Main(Prerequisite: Async/Await)","static async Task Main() as program entry point.","Default Literal(Prerequisite: Types)","default without type ( var x = default;).","Inferred Tuple Names(Prerequisite: Tuples)","Automatic tuple field names from variables ( var t = (x, y);).","Pattern Matching with Generics(Prerequisite: Pattern Matching, Generics)","Improved is and switch patterns with generic types."]},{"l":"C# 7.2 (2017)","p":["Further refinements, focusing on performance and safety.","ReadOnly Structs(Prerequisite: Structs)","readonly struct to enforce immutability.","In Parameters(Prerequisite: Methods)","in modifier for read-only reference parameters.","Ref ReadOnly Returns(Prerequisite: Ref Returns)","ref readonly for immutable reference returns.","Non-Trailing Named Arguments(Prerequisite: Named Parameters)","Named arguments anywhere in parameter list.","Private Protected Access Modifier(Prerequisite: Access Modifiers)","private protected for access within assembly and derived classes.","Conditional Ref Expressions(Prerequisite: Ref Locals)","ref in conditional expressions ( ref var x = ref (cond ? ref a : ref b);)."]},{"l":"C# 7.3 (2018)","p":["Performance and low-level programming enhancements.","Fixed Fields without Pinning(Prerequisite: Structs)","Accessing fixed-size buffers without fixed statement.","Ref Local Reassignment(Prerequisite: Ref Locals)","Reassigning ref locals.","Stackalloc Initializers(Prerequisite: Arrays)","stackalloc int[3] = { 1, 2, 3 };.","Custom Fixed Statements(Prerequisite: Structs)","fixed with custom types implementing GetPinnableReference.","Enhanced Generic Constraints(Prerequisite: Generics)","unmanaged constraint for unmanaged types.","System.Enum and System.Delegate constraints.","Tuple Equality(Prerequisite: Tuples)","== and != for tuple comparisons."]},{"l":"C# 8.0 (2019)","p":["??= for assigning if null ( x ??= defaultValue;).","$@... for verbatim interpolated strings.","Applied to arrays, strings, and SpanT.","Async Streams(Prerequisite: Async/Await, Iterators)","Default Interface Methods(Prerequisite: Interfaces)","Disposable Ref Structs(Prerequisite: Structs, IDisposable)","Enables trait-like behavior.","Enabling nullable context (#nullable enable).","Exhaustive pattern matching.","IAsyncEnumerableT and await foreach.","Index type (^1 for from-end indexing).","Indices and Ranges(Prerequisite: Arrays)","Interpolated Verbatim Strings(Prerequisite: String Interpolation)","Major features for null safety and modern patterns, building on prior type and pattern systems.","Matching on properties ( case Person { Name: John }).","Matching tuple or deconstructable types ( case (1, 2)).","Methods with implementation in interfaces.","Null-Coalescing Assignment(Prerequisite: Null-Coalescing Operator)","Nullability warnings for safer code.","Nullable Reference Types(Prerequisite: Nullable Types)","Positional Patterns(Prerequisite: Pattern Matching, Tuples)","Property Patterns(Prerequisite: Pattern Matching)","Range type ( 1..3 for slicing).","Readonly Members(Prerequisite: Structs)","readonly modifier for struct members.","ref struct with Dispose method.","Stackalloc in Nested Expressions(Prerequisite: Stackalloc)","Static Local Functions(Prerequisite: Local Functions)","static modifier for local functions to prevent capturing.","string? for nullable reference types.","Switch Expressions(Prerequisite: Pattern Matching)","Using Declarations(Prerequisite: using Statement)","Using stackalloc in expressions.","using var x = new Resource();(disposed at scope end).","var result = x switch { 1 = One, _ = Other };."]},{"l":"C# 9.0 (2020)","p":["_ for unused lambda parameters ((_, y) = y).","[ModuleInitializer] for module-level initialization.","[SkipLocalsInit] for performance optimization.","Allowing access modifiers, return types, and implementations.","Applying attributes to local functions.","Attributes on Local Functions(Prerequisite: Local Functions)","Covariant Return Types(Prerequisite: Inheritance)","delegate* for low-level function pointers (unsafe code).","Derived return types in overridden methods.","Extended Partial Methods(Prerequisite: Partial Methods)","Function Pointers(Prerequisite: Delegates)","init accessor for set-once properties.","Init-Only Properties(Prerequisite: Auto-Implemented Properties)","Lambda Discard Parameters(Prerequisite: Lambda Expressions)","Logical patterns ( and, or, not).","Module Initializers(Prerequisite: Static Classes)","Native Ints(Prerequisite: Primitive Types)","New Target-Typed Expressions(Prerequisite: Types)","new() for target-typed instantiation ( Listint list = new();).","nint and nuint for platform-dependent integers.","Parenthesized patterns ((x is int)).","Pattern Matching Enhancements(Prerequisite: Pattern Matching)","Programs without explicit Main( Console.WriteLine(Hello);).","record Person(string Name, int Age); for immutable data types.","Record Types(Prerequisite: Classes, Tuples)","Relational patterns ( case 0).","Simplifies code and enhances performance, building on patterns and types.","Skip Locals Init(Prerequisite: Variables)","Top-Level Statements(Prerequisite: Main Method)","Type patterns without variable ( if (x is int)).","Value-based equality.","with expressions for non-destructive mutation."]},{"l":"C# 10.0 (2021)","p":["(var x, y) = t; mixing declarations and assignments.","Allow const Interpolated Strings(Prerequisite: String Interpolation)","Assignment and Declaration in Same Deconstruction(Prerequisite: Tuples)","Attributes on lambdas.","Better compiler analysis for nullability and initialization.","Compile-time constant interpolated strings.","Compiler-optimized string interpolation.","Constant Interpolated Strings(Prerequisite: String Interpolation, Constants)","Explicit return types ( x = T (x * 2)).","Extended Property Patterns(Prerequisite: Property Patterns)","File-Scoped Namespaces(Prerequisite: Namespaces)","Focuses on simplifying syntax and improving records.","Global Using Directives(Prerequisite: Using Directives)","global using System; for project-wide imports.","Improved Definite Assignment(Prerequisite: Variables)","Interpolated String Handlers(Prerequisite: String Interpolation)","Interpolated strings as constants ( const string s = $Hello {World};).","Lambda Expression Improvements(Prerequisite: Lambda Expressions)","namespace MyApp; without braces.","Nested property access ({ Prop.SubProp: value }).","record struct for value-type records.","Record Structs(Prerequisite: Structs, Records)","sealed modifier for ToString in records.","Sealed Record ToString(Prerequisite: Records)"]},{"l":"C# 11.0 (2022)","p":["Auto-Default Structs(Prerequisite: Structs)","checked for user-defined arithmetic operators.","Checked User-Defined Operators(Prerequisite: Operators)","Compiler initializes struct fields to default values.","Enhanced nint/ nuint support.","Enhances string literals and generic constraints.","for multi-line, verbatim strings without escaping.","Generic Attributes(Prerequisite: Attributes, Generics)","Generic types as attributes ([MyAttributeT]).","List Patterns(Prerequisite: Pattern Matching)","Matching lists/arrays ([1, 2, ..]).","Numeric IntPtr(Prerequisite: Native Ints)","Parameterless Struct Constructors(Prerequisite: Structs)","Pattern Matching with Spans(Prerequisite: Pattern Matching, Indices and Ranges)","Patterns for SpanT and ReadOnlySpanT.","Raw String Literals(Prerequisite: Strings)","Required Members(Prerequisite: Classes, Properties)","required modifier for mandatory properties/fields.","static abstract members for interfaces.","Static Abstract Members in Interfaces(Prerequisite: Default Interface Methods)","Structs with parameterless constructors.","u8 suffix for UTF-8 strings ( textu8).","UTF-8 String Literals(Prerequisite: Strings)"]},{"l":"C# 12.0 (2023)","p":["[1, 2, 3] for arrays, lists, etc.","[Experimental] to mark APIs as experimental.","[InlineArray(10)] struct Buffer { private int _element; } for fixed-size arrays.","Alias Any Type(Prerequisite: Types)","Applies to classes and structs.","class Person(string name) for concise constructor syntax.","Collection Expressions(Prerequisite: Collection Initializers)","Default Lambda Parameters(Prerequisite: Lambda Expressions)","Experimental Attribute(Prerequisite: Attributes)","Inline Arrays(Prerequisite: Arrays)","Introduces primary constructors and collection enhancements.","Lambda parameters with defaults ((x = 0) = x).","Primary Constructors(Prerequisite: Constructors)","ref readonly for safe reference passing.","Ref Readonly Parameters(Prerequisite: In Parameters)","Spread operator ([..collection]).","using MyAlias = System.Int32; for any type."]},{"l":"C# 13.0 (2024)","p":["Focuses on flexibility and performance, building on prior features.","Params Collections(Prerequisite: Methods, Collection Expressions)","params with SpanT, ReadOnlySpanT, or collections ( void Method(params int[] args)).","Lock Object Statement(Prerequisite: Control Flow)","lock (obj) { ... } for simplified synchronization.","Method Group Natural Type(Prerequisite: Delegates)","Improved type inference for method groups in delegates.","Field Access in Auto-Properties(Prerequisite: Auto-Implemented Properties)","Accessing backing fields ( field keyword in accessors).","Partial Properties(Prerequisite: Auto-Implemented Properties, Partial Types)","partial properties with separate get/ set implementations.","Implicit Index Access(Prerequisite: Indices and Ranges)","^0 for last element access."]},{"l":"C# 14.0 (2024)","p":["Latest version, focusing on extensions and immutability.","Extension Types(Prerequisite: Classes, Extension Methods)","extension MyExtension for MyType { ... } for explicit extension types.","Encapsulates extension methods for better organization.","Immutability Annotations(Prerequisite: Nullable Reference Types)","immutable keyword for compile-time immutability checks.","Applied to types, fields, or parameters.","Improved Pattern Matching for Records(Prerequisite: Pattern Matching, Records)","Enhanced record deconstruction patterns ( case RecordType { Prop: value }).","Flexible Constructor Constraints(Prerequisite: Generics)","where T : new(...) for constructors with specific signatures.","Named Arguments in Lambda Expressions(Prerequisite: Lambda Expressions, Named Parameters)","(x: int x) = x for named lambda parameters.","Enhanced Collection Literals(Prerequisite: Collection Expressions)","Extended support for dictionaries ([key: value, ...])."]},{"l":"Notes","p":["Ordering Rationale: Features are ordered to ensure prerequisites are covered first (e.g., types before generics, delegates before lambdas). Within each version, features are grouped by category (e.g., types, control flow) to reflect a logical learning path.","Comprehensiveness: Every feature from C# 1.0 to 14.0 is included, based on official Microsoft documentation, release notes, and my knowledge up to June 2025. C# 14.0 features are sourced from .NET 9 release announcements (November 2024).","Version Accuracy: Minor features or compiler optimizations (e.g., improved overload resolution) are noted in their primary version. Some features (e.g., tuple equality in 7.3) were backported to earlier versions in specific runtimes but are listed by their official language version.","Learning Path: The outline assumes a learner starts with C# 1.0 basics (syntax, types) and progresses to advanced features (e.g., pattern matching, extensions), ensuring a scaffolded approach.","If you need a deeper dive into any feature, code examples, or a specific subset of versions, let me know!"]}],[{"l":"Linq"}],[{"l":"Overview"}],[{"l":"Overview"}],[{"l":"Overview"}],[{"l":"Benchmark your code"}],[{"l":"Blog"}],[{"l":"This is a good post"}],[{"l":"Tailwind 4 with Asp.Net"}]]